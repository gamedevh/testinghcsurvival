<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HC Survival — Optimized (Menu Fix + Working Join)</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.159/build/three.module.js",
    "three/examples/jsm/": "https://unpkg.com/three@0.159/examples/jsm/",
    "three/addons/": "https://unpkg.com/three@0.159/examples/jsm/"
  }
}
</script>

<style>
  :root{
    --bg:#0b0f1c; --panel:rgba(10,15,25,.78); --border:#1e3d59; --accent:#6ec6ff; --text:#e6eef6;
    --menuText:#eaeff7; --menuDim:#9fb4c9;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden}
  #app{position:fixed;inset:0} canvas{display:block}

  .menuOverlay{position:absolute;inset:0;pointer-events:none}
  .menuRail{position:absolute;left:24px;top:24px;bottom:24px;width:320px;display:flex;flex-direction:column;justify-content:space-between;pointer-events:none}
  .menuLogo{font-weight:900;letter-spacing:.18em;font-size:24px;color:var(--menuText);opacity:.95;text-shadow:0 2px 12px rgba(0,0,0,.5)}
  .menuList{display:flex;flex-direction:column;gap:10px;margin-top:10px}
  .menuButton{pointer-events:auto;background:transparent;border:1px solid rgba(255,255,255,.10);color:var(--menuText);text-align:left;
              padding:12px 12px;font-size:16px;border-radius:10px;backdrop-filter:blur(2px);opacity:.9;letter-spacing:.12em}
  .menuButton:hover{background:rgba(255,255,255,.06)}
  .menuSmall{color:var(--menuDim);font-size:12px;letter-spacing:.08em;margin-top:10px;opacity:.8}
  .menuCard{pointer-events:auto;background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:12px;margin-top:8px}
  .row{display:grid;grid-template-columns:1fr;gap:8px}
  label{font-size:12px;opacity:.8}
  input,select{width:100%;padding:9px 11px;border-radius:10px;border:1px solid var(--border);background:#0f1824;color:var(--text)}

  .hud{position:absolute;left:14px;bottom:14px;background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:10px;backdrop-filter:blur(4px);display:none}
  .bar{width:260px;height:10px;background:#23384f;border-radius:10px;overflow:hidden;margin:4px 0}
  .hp{background:#7bd99e;height:100%;width:100%}.hg{background:#d9b97b;height:100%}.cd{background:#7ba7d9;height:100%}
  .hotbar{position:absolute;left:50%;transform:translateX(-50%);bottom:12px;display:none;gap:8px}
  .slot{width:56px;height:56px;background:var(--panel);border:1px solid var(--border);border-radius:12px;display:flex;align-items:center;justify-content:center}
  .slot.active{outline:2px solid var(--accent)}
  .top{position:absolute;left:50%;top:10px;transform:translateX(-50%);display:none;gap:8px;background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:6px 10px}
  .btn-sm{padding:6px 10px;border-radius:8px}
  .cross{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:16px;height:16px;pointer-events:none;display:none}
  .cross:before,.cross:after{content:"";position:absolute;background:#fff}
  .cross:before{left:7px;top:0;width:2px;height:16px}.cross:after{top:7px;left:0;width:16px;height:2px}
  .chat{position:absolute;left:12px;top:12px;width:360px;max-height:44vh;overflow:auto;background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:10px;display:none}
  .say{position:absolute;left:12px;top:12px;transform:translateY(calc(100% + 10px));display:none}
  #say{width:360px;padding:8px;border-radius:8px;border:1px solid var(--border);background:#0f1824;color:var(--text)}
  .panel{position:absolute;right:12px;top:12px;width:360px;max-height:80vh;overflow:auto;background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:10px;display:none}
  .recipe,.buildbtn{display:block;width:100%;text-align:left;margin:6px 0;padding:8px 10px;background:#132033;border:1px solid var(--border);border-radius:8px;cursor:pointer}
  .hint{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.6);padding:14px 18px;border-radius:10px;border:1px solid var(--border);display:none}
  .toast{position:absolute;left:50%;top:60px;transform:translateX(-50%);background:rgba(0,0,0,.6);padding:10px 12px;border-radius:10px;border:1px solid var(--border);display:none}

  .loading{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.65);backdrop-filter:blur(2px);}
  .loadCard{width:min(540px,92vw);background:rgba(15,24,36,.92);border:1px solid #2d4a6a;border-radius:16px;padding:18px;box-shadow:0 10px 30px rgba(0,0,0,.45)}
  .loadTitle{font-size:18px;letter-spacing:.12em;margin:0 0 10px 0}
  .progress{height:12px;background:#22384f;border-radius:10px;overflow:hidden}
  .progress>div{height:100%;width:0;background:linear-gradient(90deg,#7bd99e,#6ec6ff)}
  .loadSmall{opacity:.75;font-size:12px;margin-top:8px}
  .loadRow{display:grid;grid-template-columns:1fr 60px;gap:8px;align-items:center;margin-top:8px}
</style>
</head>
<body>
<div id="app"></div>

<!-- MENU -->
<div class="menuOverlay" id="menu">
  <div class="menuRail">
    <div>
      <div class="menuLogo">HC SURVIVAL</div>
      <div class="menuList" style="margin-top:14px">
        <button class="menuButton" id="btnPlay">PLAY</button>
        <button class="menuButton" id="btnSolo">SOLO</button>
        <button class="menuButton" id="btnSettings">SETTINGS</button>
        <button class="menuButton" id="btnNews">NEWS</button>
      </div>
      <div class="menuCard">
        <div class="row">
          <div><label>Player name</label><input id="name" placeholder="Survivor"/></div>
          <div><label>Server URL (ws://…)</label><input id="server" placeholder="ws://localhost:2567"/></div>
        </div>
      </div>
      <div class="menuCard" id="settingsCard" style="display:block">
        <div class="row">
          <div><label>Graphics preset</label>
            <select id="gfx">
              <option value="auto" selected>Auto (detect)</option>
              <option value="ultra">Ultra</option>
              <option value="high">High</option>
              <option value="medium">Medium</option>
              <option value="low">Low</option>
              <option value="chromebook">Chromebook (Max Perf)</option>
            </select>
          </div>
          <div><label>FOV</label><input id="fov" type="number" value="74"/></div>
        </div>
      </div>
      <div class="menuSmall">Tip: rename to <b>index.html</b> to host on GitHub Pages.</div>
    </div>
    <div class="menuSmall">© HC Survival Prototype</div>
  </div>
</div>

<!-- LOADING -->
<div class="loading" id="loading">
  <div class="loadCard">
    <h3 class="loadTitle" id="loadTitle">Loading…</h3>
    <div class="progress"><div id="loadBar"></div></div>
    <div class="loadRow"><div class="loadSmall" id="loadDetail">Preparing world</div><div class="loadSmall" id="loadPct">0%</div></div>
  </div>
</div>

<!-- HUD -->
<div class="hud" id="hud">
  <div>HP</div><div class="bar"><div id="hp" class="hp"></div></div>
  <div>Hunger</div><div class="bar"><div id="hg" class="hg"></div></div>
  <div>Cold</div><div class="bar"><div id="cd" class="cd"></div></div>
</div>
<div class="hotbar" id="hotbar"></div>
<div class="top" id="top">
  <button class="btn-sm" id="btnLock">Pointer Lock</button>
  <button class="btn-sm" id="btnInv">Inventory (Tab)</button>
  <button class="btn-sm" id="btnCraft">Craft (C)</button>
  <button class="btn-sm" id="btnBuild">Build (B)</button>
  <button class="btn-sm" id="btnMap">Map (M)</button>
</div>
<div class="cross" id="cross"></div>
<div class="chat" id="chatlog"></div>
<div class="say" id="saywrap"><input id="say" placeholder="chat / notes (Enter)…"/></div>
<div class="panel" id="invPanel"><h3>Inventory</h3><div id="invList"></div></div>
<div class="panel" id="craftPanel"><h3>Crafting</h3><div id="craftList"></div></div>
<div class="panel" id="buildPanel"><h3>Build</h3><div id="buildList"></div></div>
<div class="hint" id="hint">Click the canvas or “Pointer Lock” to control your character.</div>
<div class="toast" id="toast"></div>

<script type="module">
import * as THREE from 'three';
import { Sky } from 'three/examples/jsm/objects/Sky.js';
import { Water } from 'three/examples/jsm/objects/Water.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

/* ---------- DOM & helpers ---------- */
const app = document.getElementById('app');
const menu = document.getElementById('menu');
const settingsCard = document.getElementById('settingsCard');
const loading = document.getElementById('loading');
const loadTitle = document.getElementById('loadTitle');
const loadBar = document.getElementById('loadBar');
const loadDetail = document.getElementById('loadDetail');
const loadPct = document.getElementById('loadPct');
const hud = document.getElementById('hud');
const topBar = document.getElementById('top');
const cross = document.getElementById('cross');
const chatlog = document.getElementById('chatlog');
const saywrap = document.getElementById('saywrap');
const invPanel = document.getElementById('invPanel');
const craftPanel = document.getElementById('craftPanel');
const buildPanel = document.getElementById('buildPanel');
const buildList = document.getElementById('buildList');
const craftList = document.getElementById('craftList');
const invList = document.getElementById('invList');
const hint = document.getElementById('hint');
const toast = document.getElementById('toast');
const hpBar = document.getElementById('hp');
const hgBar = document.getElementById('hg');
const cdBar = document.getElementById('cd');
const hotbarEl = document.getElementById('hotbar');
const nameInput = document.getElementById('name');
const serverInput = document.getElementById('server');
const gfxSelect = document.getElementById('gfx');
const fovInput = document.getElementById('fov');

const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const DPRnative = window.devicePixelRatio||1;
let renderScale = 1;
const frame = ()=> new Promise(r=>requestAnimationFrame(()=>r()));

/* ---------- Profiles & globals ---------- */
const PROFILES = {
  ultra:{ antialias:true,  shadows:true,  shadowMapSize:2048, terrainRes:384, heightmapRes:512, pixelRatioCap:2.0, post:'bloom',    water:'fancy', counts:{tree:900,rock:600,hemp:260}, fog:[150,900] },
  high: { antialias:true,  shadows:true,  shadowMapSize:1536, terrainRes:320, heightmapRes:384, pixelRatioCap:1.5, post:'bloom',    water:'fancy', counts:{tree:800,rock:500,hemp:220}, fog:[150,800] },
  medium:{antialias:true,  shadows:false, shadowMapSize:1024, terrainRes:256, heightmapRes:320, pixelRatioCap:1.25, post:'none',    water:'simple',counts:{tree:500,rock:300,hemp:120}, fog:[160,700] },
  low:  { antialias:false, shadows:false, shadowMapSize:512,  terrainRes:192, heightmapRes:256, pixelRatioCap:1.0,  post:'none',    water:'flat', counts:{tree:320,rock:160,hemp:80},  fog:[180,600] },
  chromebook:{antialias:false,shadows:false,shadowMapSize:256, terrainRes:160, heightmapRes:192, pixelRatioCap:0.95, post:'none',    water:'flat', counts:{tree:220,rock:120,hemp:60},  fog:[180,520] }
};
function detectProfile(){
  const gl = document.createElement('canvas').getContext('webgl2') || document.createElement('canvas').getContext('webgl');
  const maxTex = gl? gl.getParameter(gl.MAX_TEXTURE_SIZE) : 4096;
  const hasWebGL2 = !!document.createElement('canvas').getContext('webgl2');
  if(!hasWebGL2 || maxTex <= 4096) return 'chromebook';
  if(maxTex <= 8192) return 'medium';
  return 'high';
}

const MAP_SIZE=1024, PLAYER_EYE=1.75, GRAVITY=25, MOVE_SPEED=5.8, SPRINT=9.2, JUMP_VEL=7.8, DAY_LENGTH=20*60;
let SEED=Math.floor(Math.random()*1e9);
function lcg(seed=1337){ let s=seed>>>0; return ()=> (s=(s*1664525+1013904223)>>>0)/4294967296; }
function makeNoise2D(seed){ const rnd=lcg(seed); const grid=new Map();
  const g=(ix,iy)=>{ const k=ix+','+iy; let v=grid.get(k); if(v==null){ v=rnd()*2-1; grid.set(k,v);} return v; };
  const smooth=(x,y)=>{ const x0=Math.floor(x),y0=Math.floor(y),xf=x-x0,yf=y-y0;
    const v00=g(x0,y0),v10=g(x0+1,y0),v01=g(x0,y0+1),v11=g(x0+1,y0+1);
    const i1=lerp(v00,v10,xf), i2=lerp(v01,v11,yf); return lerp(i1,i2,yf);
  };
  return (x,y,scale=0.009,oct=4)=>{ let amp=1,f=scale,sum=0,norm=0; for(let i=0;i<oct;i++){ sum+=smooth(x*f,y*f)*amp; norm+=amp; amp*=0.5; f*=2; } return sum/norm*0.5+0.5; };
}
const noise=makeNoise2D(SEED);

/* Heightmap baked at runtime (menu uses low-res bake so menu background works) */
let PROFILE = PROFILES.high;
let HM_RES = 192, heightmap, normalmap;
function bakeHeightNormal(res){
  HM_RES=res; heightmap=new Float32Array(res*res); normalmap=new Float32Array(res*res*3);
  const step = MAP_SIZE/(res-1);
  for(let j=0;j<res;j++){ for(let i=0;i<res;i++){
    const x=-MAP_SIZE/2 + i*step, z=-MAP_SIZE/2 + j*step;
    const nx=(x+MAP_SIZE/2)/MAP_SIZE, nz=(z+MAP_SIZE/2)/MAP_SIZE;
    const island=1-Math.hypot(nx-0.5,nz-0.5)*1.35;
    const h=(noise(x+1000,z+2000,0.0025,5)*0.7 + noise(x,z,0.01,3)*0.3) * Math.max(0,island);
    const y=h*50 - 2; heightmap[j*res+i]=y;
  } }
  const e=step;
  for(let j=0;j<res;j++){ for(let i=0;i<res;i++){
    const idx=j*res+i;
    const hL=heightmap[j*res+Math.max(0,i-1)], hR=heightmap[j*res+Math.min(res-1,i+1)];
    const hD=heightmap[Math.max(0,j-1)*res+i], hU=heightmap[Math.min(res-1,j+1)*res+i];
    let nx=hL-hR, ny=2*e, nz=hD-hU; const len=1/Math.hypot(nx,ny,nz); nx*=len; ny*=len; nz*=len;
    normalmap[idx*3+0]=nx; normalmap[idx*3+1]=ny; normalmap[idx*3+2]=nz;
  } }
}
function sampleHeight(x,z){
  const fx=(x+MAP_SIZE/2)/MAP_SIZE*(HM_RES-1), fz=(z+MAP_SIZE/2)/MAP_SIZE*(HM_RES-1);
  const x0=Math.floor(fx), z0=Math.floor(fz), x1=Math.min(HM_RES-1,x0+1), z1=Math.min(HM_RES-1,z0+1);
  const tx=fx-x0, tz=fz-z0;
  const h00=heightmap[z0*HM_RES+x0], h10=heightmap[z0*HM_RES+x1], h01=heightmap[z1*HM_RES+x0], h11=heightmap[z1*HM_RES+x1];
  const a=h00*(1-tx)+h10*tx, b=h01*(1-tx)+h11*tx; return a*(1-tz)+b*tz;
}
function sampleNormal(x,z){
  const fx=(x+MAP_SIZE/2)/MAP_SIZE*(HM_RES-1), fz=(z+MAP_SIZE/2)/MAP_SIZE*(HM_RES-1);
  const xi=Math.min(HM_RES-1,Math.max(0,Math.round(fx))), zi=Math.min(HM_RES-1,Math.max(0,Math.round(fz)));
  const idx=(zi*HM_RES+xi)*3; return new THREE.Vector3(normalmap[idx],normalmap[idx+1],normalmap[idx+2]);
}
function randLand(margin=80){
  for(let i=0;i<5000;i++){ const x=-MAP_SIZE/2+margin+Math.random()*(MAP_SIZE-2*margin), z=-MAP_SIZE/2+margin+Math.random()*(MAP_SIZE-2*margin);
    if(sampleHeight(x,z)>0.5) return {x,z}; } return {x:0,z:0};
}

/* Renderer-scene globals */
let renderer=null, scene=null, camera=null, composer=null, bloomPass=null, hemi=null, sun=null, waterObj=null, terrain=null;
function lockPointer(){ if(renderer && renderer.domElement && renderer.domElement.requestPointerLock){ renderer.domElement.requestPointerLock(); } }
document.getElementById('btnLock').onclick=lockPointer;

/* MENU RENDERER (lightweight background) */
function setupMenuRenderer(){
  // Low-res bake for background
  bakeHeightNormal(160);
  renderer = new THREE.WebGLRenderer({ antialias:false, powerPreference:'high-performance' });
  renderer.setPixelRatio(Math.min(1.0, DPRnative));
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled=false;
  app.innerHTML=''; app.appendChild(renderer.domElement);
  renderer.domElement.addEventListener('click', ()=>{ if(state.mode==='game' && !document.pointerLockElement) lockPointer(); }, {capture:true});

  scene = new THREE.Scene();
  scene.background=new THREE.Color(0x0b0f1c); scene.fog=new THREE.Fog(0x0b0f1c,170,650);
  camera = new THREE.PerspectiveCamera(74, innerWidth/innerHeight, 0.1, 1800);

  hemi=new THREE.HemisphereLight(0xcde7ff,0x223344,0.55); scene.add(hemi);
  sun=new THREE.DirectionalLight(0xffffff,0.9); sun.position.set(100,200,80); scene.add(sun);

  const sky=new Sky(); sky.scale.setScalar(450000); scene.add(sky); scene.userData.sky=sky;
  sky.material.uniforms['turbidity'].value=10; sky.material.uniforms['rayleigh'].value=2; sky.material.uniforms['mieCoefficient'].value=0.005; sky.material.uniforms['mieDirectionalG'].value=0.7;

  const waterGeo=new THREE.CircleGeometry(MAP_SIZE*1.6,64);
  const ocean=new THREE.Mesh(waterGeo, new THREE.MeshStandardMaterial({color:0x2f5779, roughness:0.6, metalness:0.0}));
  ocean.rotation.x=-Math.PI/2; ocean.position.y=-2; scene.add(ocean); scene.userData.water=ocean;

  const TERR_RES=160; const geo=new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE, TERR_RES, TERR_RES); geo.rotateX(-Math.PI/2);
  const pos=geo.attributes.position; const colors=new Float32Array(pos.count*3); const nrm=geo.attributes.normal; const col=new THREE.Color();
  for(let i=0;i<pos.count;i++){ const x=pos.getX(i), z=pos.getZ(i); const y=sampleHeight(x,z); pos.setY(i,y); }
  geo.computeVertexNormals();
  for(let i=0;i<pos.count;i++){ const y=pos.getY(i); const ny=geo.attributes.normal.getY(i);
    const slope=Math.acos(clamp(ny,-1,1)); if(y<0) col.set(0x2a3d55); else { const t=1-((pos.getZ(i)+MAP_SIZE/2)/MAP_SIZE); if(slope>0.9) col.set(0x8e8e8e); else if(t<0.35) col.set(0xdde8f5); else if(t>0.70) col.set(0xd5b98a); else col.set(0x3a6a43); }
    colors[i*3]=col.r; colors[i*3+1]=col.g; colors[i*3+2]=col.b; }
  geo.setAttribute('color', new THREE.BufferAttribute(colors,3));
  const mat=new THREE.MeshStandardMaterial({vertexColors:true, roughness:0.95, metalness:0.05}); terrain=new THREE.Mesh(geo,mat); scene.add(terrain);

  composer=new EffectComposer(renderer); composer.addPass(new RenderPass(scene,camera));
  // gentle bloom for the menu only
  const bloom=new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight), 0.35, 0.95, 0.85); composer.addPass(bloom);

  // place camera
  const p=randLand(200); camera.position.set(p.x+180,220,p.z+180); camera.lookAt(p.x,0,p.z);
}

/* GAME RENDERER (rebuilt in startGame) — uses optimized version */
let terrainMat=null, inst=null, drsCooldown=0, avgFrame=1000/60;
function setupGameRenderer(profileKey){
  const PROFILE = PROFILES[profileKey];
  renderer.dispose();
  renderer = new THREE.WebGLRenderer({ antialias: PROFILE.antialias, powerPreference:'high-performance' });
  renderScale = (PROFILE===PROFILES.chromebook)?0.85 : (PROFILE===PROFILES.low?0.9:1.0);
  renderer.setPixelRatio(Math.min(PROFILE.pixelRatioCap, DPRnative)*renderScale);
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled=PROFILE.shadows; renderer.shadowMap.type=THREE.PCFSoftShadowMap;
  app.innerHTML=''; app.appendChild(renderer.domElement);
  renderer.domElement.addEventListener('click', ()=>{ if(state.mode==='game' && !document.pointerLockElement) lockPointer(); }, {capture:true});

  scene = new THREE.Scene();
  scene.background=new THREE.Color(0x0b0f1c); scene.fog=new THREE.Fog(0x0b0f1c, PROFILE.fog[0], PROFILE.fog[1]);
  camera = new THREE.PerspectiveCamera(74, innerWidth/innerHeight, 0.1, 1800);

  hemi=new THREE.HemisphereLight(0xcde7ff,0x223344,0.55); scene.add(hemi);
  sun=new THREE.DirectionalLight(0xffffff,1.0); sun.position.set(100,220,80);
  if(PROFILE.shadows){ sun.castShadow=true; sun.shadow.mapSize.set(PROFILE.shadowMapSize, PROFILE.shadowMapSize); sun.shadow.camera.left=-240; sun.shadow.camera.right=240; sun.shadow.camera.top=240; sun.shadow.camera.bottom=-240; sun.shadow.camera.near=0.5; sun.shadow.camera.far=1000; }
  scene.add(sun);

  const sky=new Sky(); sky.scale.setScalar(450000); scene.add(sky); scene.userData.sky=sky;
  sky.material.uniforms['turbidity'].value=10; sky.material.uniforms['rayleigh'].value=2; sky.material.uniforms['mieCoefficient'].value=0.005; sky.material.uniforms['mieDirectionalG'].value=0.7;

  // Water tier
  const waterGeo=new THREE.CircleGeometry(MAP_SIZE*1.6,64);
  if(PROFILE.water==='flat'){
    waterObj=new THREE.Mesh(waterGeo, new THREE.MeshStandardMaterial({color:0x2f5779, roughness:0.6, metalness:0.0}));
    waterObj.rotation.x=-Math.PI/2; waterObj.position.y=-2; scene.add(waterObj);
  }else{
    function makeWaterNormals(size=96){
      const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
      const img=ctx.createImageData(size,size); const data=img.data; const sc=0.08; const h=(x,y)=> Math.sin((x+0.1)*sc*12)+Math.cos((y-0.2)*sc*11);
      for(let y=0;y<size;y++){ for(let x=0;x<size;x++){ const hL=h(x-1,y), hR=h(x+1,y), hD=h(x,y-1), hU=h(x,y+1);
        let nx=(hL-hR), ny=(hD-hU), nz=1.0; const l=1/Math.hypot(nx,ny,nz); nx*=l; ny*=l; nz*=l;
        const i=(y*size+x)*4; data[i]=(nx*0.5+0.5)*255; data[i+1]=(ny*0.5+0.5)*255; data[i+2]=(nz*0.5+0.5)*255; data[i+3]=255; } }
      ctx.putImageData(img,0,0); const tex=new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(4,4); return tex;
    }
    waterObj=new Water(waterGeo, { textureWidth:384, textureHeight:384, waterNormals: makeWaterNormals(PROFILE.water==='fancy'?128:96), sunDirection:sun.position.clone().normalize(), sunColor:0xffffff, waterColor:0x315b7d, distortionScale: PROFILE.water==='fancy'?2.0:1.2, fog:true });
    waterObj.rotation.x=-Math.PI/2; waterObj.position.y=-2; scene.add(waterObj);
  }

  // Terrain using baked HM
  const TERR_RES = PROFILE.terrainRes;
  const geo=new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE, TERR_RES, TERR_RES); geo.rotateX(-Math.PI/2);
  const pos=geo.attributes.position;
  for(let i=0;i<pos.count;i++){ const x=pos.getX(i), z=pos.getZ(i); pos.setY(i, sampleHeight(x,z)); }
  geo.computeVertexNormals();
  const colors=new Float32Array(pos.count*3); const nm=geo.attributes.normal; const tmp=new THREE.Color();
  for(let i=0;i<pos.count;i++){ const y=pos.getY(i); const slope=Math.acos(clamp(nm.getY(i),-1,1));
    if(y<0){ tmp.set(0x2a3d55); } else { const t=1-((pos.getZ(i)+MAP_SIZE/2)/MAP_SIZE); if(slope>0.9) tmp.set(0x8e8e8e); else if(t<0.35) tmp.set(0xdde8f5); else if(t>0.70) tmp.set(0xd5b98a); else tmp.set(0x3a6a43); }
    colors[i*3]=tmp.r; colors[i*3+1]=tmp.g; colors[i*3+2]=tmp.b; }
  geo.setAttribute('color', new THREE.BufferAttribute(colors,3));
  terrain=new THREE.Mesh(geo, new THREE.MeshStandardMaterial({vertexColors:true, roughness:0.95, metalness:0.05}));
  terrain.receiveShadow=PROFILE.shadows; scene.add(terrain);

  composer=new EffectComposer(renderer); composer.addPass(new RenderPass(scene,camera));
  if(PROFILE.post==='bloom'){ const bloom=new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight), 0.55, 0.95, 0.85); composer.addPass(bloom); }

  // Instanced sets
  inst = {
    tree:{ mesh:new THREE.InstancedMesh(new THREE.CylinderGeometry(0.6,0.8,6,6), new THREE.MeshStandardMaterial({color:0x2f5d35, roughness:0.95}), PROFILES[profileKey].counts.tree), hp: new Float32Array(PROFILES[profileKey].counts.tree), alive: new Uint8Array(PROFILES[profileKey].counts.tree), yield: new Int32Array(PROFILES[profileKey].counts.tree), count:0 },
    rock:{ mesh:new THREE.InstancedMesh(new THREE.DodecahedronGeometry(1.0,0), new THREE.MeshStandardMaterial({color:0x5f6470, roughness:1.0}), PROFILES[profileKey].counts.rock), hp: new Float32Array(PROFILES[profileKey].counts.rock), alive: new Uint8Array(PROFILES[profileKey].counts.rock), yield: new Int32Array(PROFILES[profileKey].counts.rock), count:0 },
    hemp:{ mesh:new THREE.InstancedMesh(new THREE.ConeGeometry(0.4,1.2,8), new THREE.MeshStandardMaterial({color:0x6fbf73, roughness:0.95}), PROFILES[profileKey].counts.hemp), hp: new Float32Array(PROFILES[profileKey].counts.hemp), alive: new Uint8Array(PROFILES[profileKey].counts.hemp), yield: new Int32Array(PROFILES[profileKey].counts.hemp), count:0 }
  };
  for(const k of Object.keys(inst)){ const m=inst[k].mesh; m.instanceMatrix.setUsage(THREE.DynamicDrawUsage); m.castShadow=(k!=='hemp') && PROFILES[profileKey].shadows; scene.add(m); }

  function addInstance(type, x,y,z){
    const def = inst[type]; if(def.count>=def.hp.length) return; const id=def.count++;
    const m=new THREE.Matrix4(); const s= type==='hemp'?1.0: (type==='rock'?(0.7+Math.random()*0.6):(0.9+Math.random()*0.4));
    m.compose(new THREE.Vector3(x,y,z), new THREE.Quaternion(), new THREE.Vector3(s,s,s));
    def.mesh.setMatrixAt(id,m); def.mesh.instanceMatrix.needsUpdate=true;
    def.hp[id]= type==='rock'?70:(type==='tree'?60:10); def.alive[id]=1; def.yield[id]= type==='rock'?(50+Math.floor(Math.random()*35)) : type==='tree'?(40+Math.floor(Math.random()*30)) : (10+Math.floor(Math.random()*10));
  }
  function spawnCounts(counts){ for(let i=0;i<counts.tree;i++){ const p=randLand(); addInstance('tree', p.x, sampleHeight(p.x,p.z)+3, p.z); } for(let i=0;i<counts.rock;i++){ const p=randLand(); addInstance('rock', p.x, sampleHeight(p.x,p.z)+1, p.z); } for(let i=0;i<counts.hemp;i++){ const p=randLand(); addInstance('hemp', p.x, sampleHeight(p.x,p.z)+0.6, p.z); } }
  scene.userData.spawnCounts = spawnCounts;
}

/* UI helpers */
function showHUD(show){ hud.style.display=show?'block':'none'; hotbarEl.style.display=show?'flex':'none'; topBar.style.display=show?'flex':'none'; cross.style.display=show?'block':'none'; chatlog.style.display=show?'block':'none'; saywrap.style.display=show?'block':'none'; }
function toggle(p){ p.style.display=(p.style.display==='block'?'none':'block'); }
function tip(s,ms=1200){ toast.textContent=s; toast.style.display='block'; setTimeout(()=>toast.style.display='none', ms); }
function renderHotbar(){ hotbarEl.innerHTML=''; for(let i=0;i<5;i++){ const d=document.createElement('div'); d.className='slot'+(i===state.me.slot?' active':'');
  const id=state.me.hotbar[i]; d.textContent=id? id[0].toUpperCase() : (i+1); hotbarEl.appendChild(d); } }
function renderInventory(){ invList.innerHTML=''; const inv=state.me.inv; const ks=Object.keys(inv).sort(); if(!ks.length) invList.textContent='(empty)';
  for(const k of ks){ const row=document.createElement('div'); row.textContent=`${k}: ${inv[k]}`; invList.appendChild(row); } }

/* Game data */
const state={ time:0, mode:'menu', me:{ x:0, y:PLAYER_EYE, z:0, vx:0, vy:0, vz:0, yaw:0, pitch:0, onGround:false, hp:100, hunger:100, cold:0, inv:{rock:1,torch:1,arrow:0}, hotbar:['rock','torch',null,null,null], slot:0, wb:0, bps:[] },
  buildMeshes:new Map(), remotePlayers:new Map() };

/* Movement & helpers */
function updateCamera(){ camera.rotation.set(0,0,0); camera.rotateY(state.me.yaw); camera.rotateX(state.me.pitch); camera.position.set(state.me.x,state.me.y,state.me.z); }
const raycaster=new THREE.Raycaster();
function terrainNormal(x,z){ return sampleNormal(x,z); }
function moveLocal(dt){
  const forward=new THREE.Vector3(0,0,-1).applyEuler(camera.rotation); forward.y=0; forward.normalize();
  const right=new THREE.Vector3(1,0,0).applyEuler(camera.rotation); right.y=0; right.normalize();
  let wish=new THREE.Vector3(); if(keys['KeyW']) wish.add(forward); if(keys['KeyS']) wish.add(forward.clone().multiplyScalar(-1)); if(keys['KeyA']) wish.add(right.clone().multiplyScalar(-1)); if(keys['KeyD']) wish.add(right);
  const speed=keys['ShiftLeft']?SPRINT:MOVE_SPEED; if(wish.lengthSq()>0) wish.normalize().multiplyScalar(speed);
  const ACC=30; state.me.vx=lerp(state.me.vx, wish.x, ACC*dt); state.me.vz=lerp(state.me.vz, wish.z, ACC*dt);
  state.me.vy -= GRAVITY*dt; if(keys['Space'] && state.me.onGround){ state.me.vy=JUMP_VEL; state.me.onGround=false; }
  let nx=state.me.x+state.me.vx*dt, nz=state.me.z+state.me.vz*dt;
  const gN=terrainNormal(nx,nz), slopeAngle=Math.acos(clamp(gN.y,-1,1)); if(slopeAngle>0.9){ const down=new THREE.Vector3(-gN.x,0,-gN.z).normalize().multiplyScalar(2.0); nx+=down.x*dt; nz+=down.z*dt; }
  const gy=sampleHeight(nx,nz)+PLAYER_EYE; let ny=state.me.y+state.me.vy*dt; if(ny<=gy){ ny=gy; state.me.vy=0; state.me.onGround=true; } else state.me.onGround=false;
  state.me.x=nx; state.me.y=ny; state.me.z=nz; updateCamera();
}

/* Controls */
let pointerLocked=false, keys={};
document.addEventListener('pointerlockchange', ()=>{ pointerLocked = document.pointerLockElement===renderer.domElement; hint.style.display = pointerLocked?'none':'block'; });
document.addEventListener('mousemove', (e)=>{ if(!pointerLocked || state.mode!=='game') return; const sens=0.0020; state.me.yaw -= e.movementX*sens; state.me.pitch -= e.movementY*sens; state.me.pitch = clamp(state.me.pitch,-Math.PI/2+0.01,Math.PI/2-0.01); });
addEventListener('keydown', (e)=>{
  if(state.mode==='menu'){ if(e.code==='KeyS') settingsCard.style.display=(settingsCard.style.display==='none'?'block':'none'); return; }
  if(e.code==='Tab'){ e.preventDefault(); toggle(invPanel); renderInventory(); return; }
  if(e.code==='KeyC'){ toggle(craftPanel); renderCrafting(); return; }
  if(e.code==='KeyB'){ toggle(buildPanel); renderBuild(); return; }
  if(['Digit1','Digit2','Digit3','Digit4','Digit5'].includes(e.code)){ state.me.slot=Number(e.code.slice(-1))-1; renderHotbar(); }
  if(e.code==='Enter'){ document.getElementById('say').focus(); }
  keys[e.code]=true;
});
addEventListener('keyup', (e)=>{ keys[e.code]=false; });

/* Build & Craft (minimal for this fix) */
const RECIPES=[ {out:'spear', need:{wood:200,stone:50}}, {out:'bow', need:{wood:200,cloth:50}}, {out:'campfire', need:{wood:100}} ];
function renderCrafting(){ craftList.innerHTML=''; for(const r of RECIPES){ const btn=document.createElement('button'); btn.className='recipe'; btn.textContent=r.out; btn.onclick=()=>toast.textContent='(crafting placeholder)'; craftList.appendChild(btn); } }
function renderBuild(){ buildList.innerHTML=''; ['Foundation','Wall','Doorway','TC','Campfire','Workbench'].forEach((n)=>{ const b=document.createElement('button'); b.className='buildbtn'; b.textContent=n; buildList.appendChild(b); }); }

/* Loading helpers */
function setLoading(show, title='Loading…', detail='Please wait', pct=0){
  loading.style.display=show?'flex':'none';
  loadTitle.textContent=title; loadDetail.textContent=detail; loadBar.style.width=Math.round(pct)+'%'; loadPct.textContent=Math.round(pct)+'%';
}

/* Start Game */
document.getElementById('btnSettings').onclick=()=>{ settingsCard.style.display=(settingsCard.style.display==='none'?'block':'none'); };
document.getElementById('btnNews').onclick=()=>{ alert('HC Survival prototype — dev build.'); };
document.getElementById('btnPlay').onclick=()=> startGame('mp');
document.getElementById('btnSolo').onclick=()=> startGame('solo');

async function startGame(mode){
  state.mode='loading'; menu.style.display='none';
  setLoading(true,'Loading world…','Selecting profile',5);

  let chosen = (gfxSelect.value==='auto') ? detectProfile() : gfxSelect.value;
  const P = PROFILES[chosen] || PROFILES.high;

  setLoading(true,'Loading world…','Baking heightmap',12);
  bakeHeightNormal(P.heightmapRes); await frame();

  setLoading(true,'Loading world…','Configuring renderer',20);
  setupGameRenderer(chosen); await frame();

  setLoading(true,'Loading world…','Spawning world',55);
  scene.userData.spawnCounts(P.counts); await frame();

  setLoading(true,'Optimizing…','Compiling shaders',72);
  renderer.compile(scene,camera); for(let i=0;i<2;i++){ composer.render(); await frame(); }

  const p=randLand(120); state.me.x=p.x; state.me.z=p.z; state.me.y=sampleHeight(p.x,p.z)+PLAYER_EYE; updateCamera();
  camera.fov = clamp(parseInt(fovInput.value||'74',10),60,100); camera.updateProjectionMatrix();

  setLoading(true,'Finalizing…','Warm-up frames',90); for(let i=0;i<2;i++){ composer.render(); await frame(); }
  setLoading(true,'Done','Click to lock pointer',100); await frame();

  loading.style.display='none'; state.mode='game'; showHUD(true); renderHotbar(); renderCrafting(); renderBuild();
}

/* Loop */
let last=performance.now();
function loop(){
  const now=performance.now(), dt=Math.min(0.05,(now-last)/1000); last=now; state.time+=dt;

  if(!renderer || !composer || !scene || !camera){ requestAnimationFrame(loop); return; }

  // Day/night & menu orbit
  const sky = scene.userData.sky;
  const t=(state.time % DAY_LENGTH)/DAY_LENGTH, phi=THREE.MathUtils.degToRad(90 - t*360), theta=THREE.MathUtils.degToRad(180);
  if(sky){ const sunVec=new THREE.Vector3().setFromSphericalCoords(1,phi,theta); if(sun){ sun.position.copy(sunVec.multiplyScalar(320)); } sky.material.uniforms['sunPosition'].value.copy(sun?sun.position:new THREE.Vector3()); }

  if(state.mode==='menu'){
    const r=260, ang=state.time*0.05; camera.position.set(Math.cos(ang)*r,220,Math.sin(ang)*r); camera.lookAt(0,0,0);
  } else if(state.mode==='game'){
    moveLocal(dt);
  }

  composer.render();
  requestAnimationFrame(loop);
}
setupMenuRenderer();
requestAnimationFrame(loop);

/* Resize */
addEventListener('resize', ()=>{ if(!renderer||!camera||!composer) return; renderer.setSize(innerWidth, innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); composer.setSize(innerWidth, innerHeight); });

// Defaults
serverInput.value='ws://localhost:2567'; nameInput.value='Survivor';
</script>
</body>
</html>
